import os

from triton import *
import lief


# Script options
DEBUG = True

# Memory mapping
BASE_PLT   = 0x10000000
BASE_ARGV  = 0x20000000
BASE_ALLOC = 0x30000000
BASE_STACK = 0x9fffffff

# Covers the possible call and return addreesses of the entire program, starting at an entry point (main)
# Code from https://github.com/JonathanSalwan/Triton/blob/master/src/examples/python/ctf-writeups/defcamp-2015-r100/solve.py
def cover(starting_instruction):
	count = 0
	print('[+] Starting emulation.')
	pc = starting_instruction # set program counter to starting instruction
	while pc:
		# Fetch opcode
		opcodes = getConcreteMemoryAreaValue(pc, 16)

		# Create the Triton instruction
		instruction = Instruction()
		instruction.setOpcodes(opcodes)
		instruction.setAddress(pc)
		# Process
		processing(instruction)
		print(instruction)

		if instruction.getType() == OPCODE.HLT:
			break

		"""
		# 40078B: cmp eax, 1
		# eax must be equal to 1 at each round.
		if instruction.getAddress() == 0x40078B:
			# Slice expressions
			rax   = Triton.getSymbolicRegister(Triton.registers.rax)
			eax   = astContext.extract(31, 0, rax.getAst())

			# Define constraint
			cstr  = astContext.land([
				Triton.getPathConstraintsAst(),
				astContext.equal(eax, astCtxt.bv(1, 32))
				])

			print('[+] Asking for a model, please wait...')
			model = Triton.getModel(cstr)
			for k, v in list(model.items()):
				value = v.getValue()
				Triton.setConcreteVariableValue(Triton.getSymbolicVariableFromId(k), value)
				print('[+] Symbolic variable %02d = %02x (%c)' %(k, value, chr(value)))
		"""
		# Next
		if(str(instruction).find("call") > 0) :
			#print instruction
			pc += instruction.getSize()
			print("Solved addr:" + hex(buildSymbolicRegister(REG.RIP).evaluate()))
		else:
			pc = getConcreteRegisterValue(REG.RIP)
		count += 1

	print('[+] Emulation done.')
	return

# Load segments into triton.
# Code from https://github.com/JonathanSalwan/Triton/blob/master/src/examples/python/ctf-writeups/defcamp-2015-r100/solve.py
def loadBinary(bin_path):
    # Map the binary into the memory
    triton_bin = Elf(os.path.join(os.path.dirname(__file__), 'main'))
    raw = triton_bin.getRaw()
    segments = triton_bin.getProgramHeaders()
    for phdr in segments:
        offset = phdr.getOffset()
        size   = phdr.getFilesz()
        vaddr  = phdr.getVaddr()
        #print('Loading 0x%06x - 0x%06x' %(vaddr, vaddr+size))
        setConcreteMemoryAreaValue(vaddr, raw[offset:offset+size])
    
    lief_bin = lief.parse(os.path.join(os.path.dirname(__file__), 'main'))
    symbols = lief_bin.symbols
    for symbol in symbols:
    	if(symbol.type == lief.ELF.SYMBOL_TYPES.FUNC and symbol.name == "main"):
    		print("Found main function: " + str(symbol))
    		return symbol.value

if __name__ == '__main__':
	# Set the architecture
    setArchitecture(ARCH.X86_64)

    # Set a symbolic optimization mode
    enableMode(MODE.ALIGNED_MEMORY, True)
    
    # Parse the binary
    #binary = Elf(os.path.join(os.path.dirname(__file__), 'main'))
    bin_path = os.path.join(os.path.dirname(__file__), 'main')
    print('Starting coverage')
    main_addr = loadBinary(bin_path)

    # Define a fake stack
    setConcreteRegisterValue(Register(REG.RBP, BASE_STACK))
    concretizeRegister(REG.RSP)

    cover(0x4005d8)
    #cover(main_addr)
    print('Coverage done')
    